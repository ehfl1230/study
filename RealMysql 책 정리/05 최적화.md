1. 풀 테이블 스캔
- 풀 테이블 스캔하는 경우
  * 테이블의 레코드 건수가 너무 작아 인덱스를 타는 것보다 풀 테이블 스캔이 효율적일 경우
  * 인덱스를 이용할 수 있는 조건 없을 경우
  * 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- InnoDB나 XtraDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(어떤 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 읽어 버퍼풀에 가져오는 행위) 작업을 자동으로 수행함.
- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기 수행하고 특정 시점부터는 백그라운드 스레드로 넘김. 백그라운드에서 미리 처리하여 버퍼 풀에 저장해두므로 쿼리가 상당히 빨리 처리된다.
- 데이터웨어하우스용으로 사용한다면 innodb_read_ahead_threshold 옵션을 낮게 설정해서 더 자주 리드 어헤드가 시작되도록 하는 것이 좋음. 
2. ORDER BY 처리
- 정렬을 하기 위한 방법
  | | 장점 | 단점 |
  |---|:---|:---|
  | 인덱스사용 |생성, 수정, 삭제 쿼리가 실행될때 이미 정렬되어 있어서 매우 빠름 | 생성, 수정, 삭제 작업 시 부가적인 인덱스 추가/삭제 작업이 필요.<br>인덱스 때문에 더 많은 디스크 공간 필요.<br>인덱스 개수가 늘어날수록 innodb 버퍼 풀이나 myISAM 키 캐시용 메모리가 많이 필요하다.|
  | Filesort사용 | 인덱스의 단점.<br>정렬해야할 레코드가 많지 않으면 메모리에서 filesort가 처리되므로 빠름 | 정렬 작업이 쿼리 실행할 때 처리되어 응답속도 느림.|
- 실행계획의 extra 컬럼에 using filesort라는 코멘트가 표시되면 인덱스를 이용하지 않고 별도의 파일 정렬을 사용한 것.
2.1 소트 버퍼 (Sort Buffer)
- 정렬 수행위해 별도의 메모리 공간 할당받아 사용. 최대 사용 가능한 소트 버퍼 공간은 sort_buffer_size 라는 시스템 변수 설정으로 가능
- 소트 버퍼 공간은 쿼리 실행 완료되면 바로 반납됨.
- 정렬해야 할 레코드 건수가 할당된 공간보다 크다면?
 * 레코드를 여러 조각으로 나눠서 처리하고 임시로 디스크에 기록을 반복함. 그리고 병합하면서 정렬 수행.
 * 이 작업들은 모두 디스크 쓰기&읽기 유발
 * 소트 버퍼 크게 하는 건 거의 차이가 없음. 256kb ~ 512kb가 최적이고 더 커지는 건 성능상 차이x. 8MB 이상이면 선능 조금 더 향상됨.
