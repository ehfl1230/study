1. 풀 테이블 스캔
- 풀 테이블 스캔하는 경우
  * 테이블의 레코드 건수가 너무 작아 인덱스를 타는 것보다 풀 테이블 스캔이 효율적일 경우
  * 인덱스를 이용할 수 있는 조건 없을 경우
  * 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- InnoDB나 XtraDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(어떤 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 읽어 버퍼풀에 가져오는 행위) 작업을 자동으로 수행함.
- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기 수행하고 특정 시점부터는 백그라운드 스레드로 넘김. 백그라운드에서 미리 처리하여 버퍼 풀에 저장해두므로 쿼리가 상당히 빨리 처리된다.
- 데이터웨어하우스용으로 사용한다면 innodb_read_ahead_threshold 옵션을 낮게 설정해서 더 자주 리드 어헤드가 시작되도록 하는 것이 좋음. 
2. ORDER BY 처리
- 정렬을 하기 위한 방법
  | | 장점 | 단점 |
  |---|:---|:---|
  | 인덱스사용 |생성, 수정, 삭제 쿼리가 실행될때 이미 정렬되어 있어서 매우 빠름 | 생성, 수정, 삭제 작업 시 부가적인 인덱스 추가/삭제 작업이 필요.<br>인덱스 때문에 더 많은 디스크 공간 필요.<br>인덱스 개수가 늘어날수록 innodb 버퍼 풀이나 myISAM 키 캐시용 메모리가 많이 필요하다.|
  | Filesort사용 | 인덱스의 단점.<br>정렬해야할 레코드가 많지 않으면 메모리에서 filesort가 처리되므로 빠름 | 정렬 작업이 쿼리 실행할 때 처리되어 응답속도 느림.|
- 실행계획의 extra 컬럼에 using filesort라는 코멘트가 표시되면 인덱스를 이용하지 않고 별도의 파일 정렬을 사용한 것.
2.1 소트 버퍼 (Sort Buffer)
- 정렬 수행위해 별도의 메모리 공간 할당받아 사용. 최대 사용 가능한 소트 버퍼 공간은 sort_buffer_size 라는 시스템 변수 설정으로 가능
- 소트 버퍼 공간은 쿼리 실행 완료되면 바로 반납됨.
- 정렬해야 할 레코드 건수가 할당된 공간보다 크다면?
 * 레코드를 여러 조각으로 나눠서 처리하고 임시로 디스크에 기록을 반복함. 그리고 병합하면서 정렬 수행.
 * 이 작업들은 모두 디스크 쓰기&읽기 유발
 * 소트 버퍼 크게 하는 건 거의 차이가 없음. 256kb ~ 512kb가 최적이고 더 커지는 건 성능상 차이x. 8MB 이상이면 선능 조금 더 향상됨.

2.2 정렬알고리즘
||싱글 패스 알고리즘|투 패스 알고리즘|
|---|:---|:---|
|정렬방법|소트 버퍼에 정렬 기준 칼럼을 포함해<br>SELECT 되는 컬럼 전부를 담아서 정렬 수행하는 방법|정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아 정렬하고<br>정렬 순서대로 다시 프라이머리키로 테이블 읽어서 가져오는 방법|
|테이블read|한번만 읽음|두번 읽어야 해서 불합리|
|버퍼공간|많이 필요|적게 필요|
|성능효율|레코드의 크기나 건수가 작은 경우 좋음|레코드 크기나 건수가 상당히 많은 경우 좋음|

2.3 정렬 처리 방식
|정렬 처리 방법|실행 계획 extra 코멘트|
|---|:---|
|인덱스 사용시|별도 표기 없음|
|드라이빙 테이블만 정렬<br>(조인이 없는 경우 포함)|Using filesort|
|조인 결과를 임시 테이블로 저장한 후, 임시 테이블에서 정렬|Using temporary; Using filesort|
* 인덱스를 사용할 수 없는 경우 옵티마이저는 정렬 대상 레코드 최소화하기 위해 다음 두 가지 방법 중 하나 사용
- 드라이빙 테이블만 정렬한 다음 조인을 수행 (더 효율적)
- 조인이 끝나고 일치하는 레를 모두 가져올 후 정렬 수행 

2.3.1 인덱스를 사용한 정렬
2.3.2 드라이빙 테이블만 정렬
2.3.3 임시 테이블을 이용한 정렬
2.3.4 정렬 방식의 성능 비교

2.4 ORDER BY .. LIMIT n 최적화
2.5 정렬 관련 상태 변수



