1. 풀 테이블 스캔
- 풀 테이블 스캔하는 경우
  * 테이블의 레코드 건수가 너무 작아 인덱스를 타는 것보다 풀 테이블 스캔이 효율적일 경우
  * 인덱스를 이용할 수 있는 조건 없을 경우
  * 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- InnoDB나 XtraDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(어떤 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 읽어 버퍼풀에 가져오는 행위) 작업을 자동으로 수행함.
- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기 수행하고 특정 시점부터는 백그라운드 스레드로 넘김. 백그라운드에서 미리 처리하여 버퍼 풀에 저장해두므로 쿼리가 상당히 빨리 처리된다.
- 데이터웨어하우스용으로 사용한다면 innodb_read_ahead_threshold 옵션을 낮게 설정해서 더 자주 리드 어헤드가 시작되도록 하는 것이 좋음. 
2. ORDER BY 처리
- 정렬을 하기 위한 방법
  | | 장점 | 단점 |
  |---|:---|:---|
  | 인덱스사용 |생성, 수정, 삭제 쿼리가 실행될때 이미 정렬되어 있어서 매우 빠름 | 생성, 수정, 삭제 작업 시 부가적인 인덱스 추가/삭제 작업이 필요.<br>인덱스 때문에 더 많은 디스크 공간 필요.<br>인덱스 개수가 늘어날수록 innodb 버퍼 풀이나 myISAM 키 캐시용 메모리가 많이 필요하다.|
  | Filesort사용 | 인덱스의 단점.<br>정렬해야할 레코드가 많지 않으면 메모리에서 filesort가 처리되므로 빠름 | 정렬 작업이 쿼리 실행할 때 처리되어 응답속도 느림.|
- 실행계획의 extra 컬럼에 using filesort라는 코멘트가 표시되면 인덱스를 이용하지 않고 별도의 파일 정렬을 사용한 것.
2.1 소트 버퍼 (Sort Buffer)
- 정렬 수행위해 별도의 메모리 공간 할당받아 사용. 최대 사용 가능한 소트 버퍼 공간은 sort_buffer_size 라는 시스템 변수 설정으로 가능
- 소트 버퍼 공간은 쿼리 실행 완료되면 바로 반납됨.
- 정렬해야 할 레코드 건수가 할당된 공간보다 크다면?
 * 레코드를 여러 조각으로 나눠서 처리하고 임시로 디스크에 기록을 반복함. 그리고 병합하면서 정렬 수행.
 * 이 작업들은 모두 디스크 쓰기&읽기 유발
 * 소트 버퍼 크게 하는 건 거의 차이가 없음. 256kb ~ 512kb가 최적이고 더 커지는 건 성능상 차이x. 8MB 이상이면 선능 조금 더 향상됨.

2.2 정렬알고리즘
||싱글 패스 알고리즘|투 패스 알고리즘|
|---|:---|:---|
|정렬방법|소트 버퍼에 정렬 기준 칼럼을 포함해<br>SELECT 되는 컬럼 전부를 담아서 정렬 수행하는 방법|정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아 정렬하고<br>정렬 순서대로 다시 프라이머리키로 테이블 읽어서 가져오는 방법|
|테이블read|한번만 읽음|두번 읽어야 해서 불합리|
|버퍼공간|많이 필요|적게 필요|
|성능효율|레코드의 크기나 건수가 작은 경우 좋음|레코드 크기나 건수가 상당히 많은 경우 좋음|

2.3 정렬 처리 방식
|정렬 처리 방법|실행 계획 extra 코멘트|
|---|:---|
|인덱스 사용시|별도 표기 없음|
|드라이빙 테이블만 정렬<br>(조인이 없는 경우 포함)|Using filesort|
|조인 결과를 임시 테이블로 저장한 후, 임시 테이블에서 정렬|Using temporary; Using filesort|
* 인덱스를 사용할 수 없는 경우 옵티마이저는 정렬 대상 레코드 최소화하기 위해 다음 두 가지 방법 중 하나 사용
- 드라이빙 테이블만 정렬한 다음 조인을 수행 (더 효율적)
- 조인이 끝나고 일치하는 레를 모두 가져올 후 정렬 수행 

2.3.1 인덱스를 사용한 정렬
* 반드시 order by에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고, order by의 순서대로 인덱스가 있어야 함.
* where 절에 첫 번째 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 order by는 같은 조건을 사용할 수 있어야 함.
* 해시 인덱스나 전문 검색 인덱스에서는 인덱스를 이용한 정렬을 사용할 수 없음.

* 인덱스를 이용해서 처리되는 경우는 인덱스 값이 이미 정렬되어 있기 때문에 인덱스 순서대로 읽기만 하면됨.
* 그렇다고 order by 절에서 완전 빼지는 말것

2.3.2 드라이빙 테이블만 정렬
* 드라이빙 테이블의 컬럼만으로 order by 절이 작성되어야 한다.
* 옵티마이저는 드라이빙 테이블만 검색해서 정렬 먼저 수행하고 결과와 드리븐 테이블을 조인한다.

2.3.3 임시 테이블을 이용한 정렬
- 가장 느린 정렬 방법
- order by 절이 드리븐 테이블의 컬럼으로 구성되어 있을 경우, 조인 후 정렬한다. 

2.3.4 정렬 방식의 성능 비교
* 스트리밍 방식
- 조건에 일치하는 레코드가 검색될 때 바로 전송해주는 방식
- LIMIT사용하면 실행시간을 상당히 줄여줌.

* 버퍼링 처리
- order by나 group by는 스트리밍이 불가능
- limit 걸어도 성능 향상에 별로 도움이 되지 않는다.

* 위에서 언급한 정렬방법 세 가지 중에 인덱스를 사용한 정렬 방식만 스트리밍 형태

2.4 ORDER BY .. LIMIT n 최적화
- 인덱스 사용 못하는 경우 조건절에 일치하는 레코드들을 모두 가져와서 소트 버퍼를 이용해 퀵소트함.
- 데이터가 너무 많으면 소트 버퍼 크기 만큼 레코드 모아서 정렬하고 정렬된 결과 병합하는데 cpu, 디스크에 많음 부담.

- 전체 데이터건수는 많은데 LIMIT으로 인하여 실제 리턴해야 할 데이터는 적은 경우, 소트 버퍼에 우선순위 큐 만들고 큐를 이용해서 정렬 수행

2.5 정렬 관련 상태 변수
* show session status like 'Sort%'; 명령어를 통해 확인 가능
- Sort_merge_passws 멀티 머지 처리 횟수
- Sort_range 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수.
- Sort_scan 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수. Sort_scan과 Sort_range는 둘 다 정렬 작업 횟수를 누적함.
- Sort_row는 지금까지 정렬한 전체 레코드 



