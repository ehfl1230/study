1. 풀 테이블 스캔
- 풀 테이블 스캔하는 경우
  * 테이블의 레코드 건수가 너무 작아 인덱스를 타는 것보다 풀 테이블 스캔이 효율적일 경우
  * 인덱스를 이용할 수 있는 조건 없을 경우
  * 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- InnoDB나 XtraDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드(어떤 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 읽어 버퍼풀에 가져오는 행위) 작업을 자동으로 수행함.
- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기 수행하고 특정 시점부터는 백그라운드 스레드로 넘김. 백그라운드에서 미리 처리하여 버퍼 풀에 저장해두므로 쿼리가 상당히 빨리 처리된다.
- 데이터웨어하우스용으로 사용한다면 innodb_read_ahead_threshold 옵션을 낮게 설정해서 더 자주 리드 어헤드가 시작되도록 하는 것이 좋음. 
2. ORDER BY 처리
- 정렬을 하기 위한 방법
  | | 장점 | 단점 |
  |---|:---|:---|
  | 인덱스사용 |생성, 수정, 삭제 쿼리가 실행될때 이미 정렬되어 있어서 매우 빠름 | 생성, 수정, 삭제 작업 시 부가적인 인덱스 추가/삭제 작업이 필요.<br>인덱스 때문에 더 많은 디스크 공간 필요.<br>인덱스 개수가 늘어날수록 innodb 버퍼 풀이나 myISAM 키 캐시용 메모리가 많이 필요하다.|
  | Filesort사용 | 인덱스의 단점.<br>정렬해야할 레코드가 많지 않으면 메모리에서 filesort가 처리되므로 빠름 | 정렬 작업이 쿼리 실행할 때 처리되어 응답속도 느림.|
- 실행계획의 extra 컬럼에 using filesort라는 코멘트가 표시되면 인덱스를 이용하지 않고 별도의 파일 정렬을 사용한 것.
2.1 소트 버퍼 (Sort Buffer)
- 정렬 수행위해 별도의 메모리 공간 할당받아 사용. 최대 사용 가능한 소트 버퍼 공간은 sort_buffer_size 라는 시스템 변수 설정으로 가능
- 소트 버퍼 공간은 쿼리 실행 완료되면 바로 반납됨.
- 정렬해야 할 레코드 건수가 할당된 공간보다 크다면?
 * 레코드를 여러 조각으로 나눠서 처리하고 임시로 디스크에 기록을 반복함. 그리고 병합하면서 정렬 수행.
 * 이 작업들은 모두 디스크 쓰기&읽기 유발
 * 소트 버퍼 크게 하는 건 거의 차이가 없음. 256kb ~ 512kb가 최적이고 더 커지는 건 성능상 차이x. 8MB 이상이면 선능 조금 더 향상됨.

2.2 정렬알고리즘
||싱글 패스 알고리즘|투 패스 알고리즘|
|---|:---|:---|
|정렬방법|소트 버퍼에 정렬 기준 칼럼을 포함해<br>SELECT 되는 컬럼 전부를 담아서 정렬 수행하는 방법|정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아 정렬하고<br>정렬 순서대로 다시 프라이머리키로 테이블 읽어서 가져오는 방법|
|테이블read|한번만 읽음|두번 읽어야 해서 불합리|
|버퍼공간|많이 필요|적게 필요|
|성능효율|레코드의 크기나 건수가 작은 경우 좋음|레코드 크기나 건수가 상당히 많은 경우 좋음|

2.3 정렬 처리 방식
|정렬 처리 방법|실행 계획 extra 코멘트|
|---|:---|
|인덱스 사용시|별도 표기 없음|
|드라이빙 테이블만 정렬<br>(조인이 없는 경우 포함)|Using filesort|
|조인 결과를 임시 테이블로 저장한 후, 임시 테이블에서 정렬|Using temporary; Using filesort|
* 인덱스를 사용할 수 없는 경우 옵티마이저는 정렬 대상 레코드 최소화하기 위해 다음 두 가지 방법 중 하나 사용
- 드라이빙 테이블만 정렬한 다음 조인을 수행 (더 효율적)
- 조인이 끝나고 일치하는 레를 모두 가져올 후 정렬 수행 

2.3.1 인덱스를 사용한 정렬
* 반드시 order by에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고, order by의 순서대로 인덱스가 있어야 함.
* where 절에 첫 번째 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 order by는 같은 조건을 사용할 수 있어야 함.
* 해시 인덱스나 전문 검색 인덱스에서는 인덱스를 이용한 정렬을 사용할 수 없음.

* 인덱스를 이용해서 처리되는 경우는 인덱스 값이 이미 정렬되어 있기 때문에 인덱스 순서대로 읽기만 하면됨.
* 그렇다고 order by 절에서 완전 빼지는 말것

2.3.2 드라이빙 테이블만 정렬
* 드라이빙 테이블의 컬럼만으로 order by 절이 작성되어야 한다.
* 옵티마이저는 드라이빙 테이블만 검색해서 정렬 먼저 수행하고 결과와 드리븐 테이블을 조인한다.

2.3.3 임시 테이블을 이용한 정렬
- 가장 느린 정렬 방법
- order by 절이 드리븐 테이블의 컬럼으로 구성되어 있을 경우, 조인 후 정렬한다. 

2.3.4 정렬 방식의 성능 비교
- 스트리밍 방식
 * 조건에 일치하는 레코드가 검색될 때 바로 전송해주는 방식
 * LIMIT사용하면 실행시간을 상당히 줄여줌.

- 버퍼링 처리
 * order by나 group by는 스트리밍이 불가능
 * limit 걸어도 성능 향상에 별로 도움이 되지 않는다.

- 위에서 언급한 정렬방법 세 가지 중에 인덱스를 사용한 정렬 방식만 스트리밍 형태

2.4 ORDER BY .. LIMIT n 최적화
- 인덱스 사용 못하는 경우 조건절에 일치하는 레코드들을 모두 가져와서 소트 버퍼를 이용해 퀵소트함.
- 데이터가 너무 많으면 소트 버퍼 크기 만큼 레코드 모아서 정렬하고 정렬된 결과 병합하는데 cpu, 디스크에 많음 부담.

- 전체 데이터건수는 많은데 LIMIT으로 인하여 실제 리턴해야 할 데이터는 적은 경우, 소트 버퍼에 우선순위 큐 만들고 큐를 이용해서 정렬 수행

2.5 정렬 관련 상태 변수
_ show session status like 'Sort%'; 명령어를 통해 확인 가능
 * Sort_merge_passws 멀티 머지 처리 횟수
 * Sort_range 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수.
 * Sort_scan 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수. Sort_scan과 Sort_range는 둘 다 정렬 작업 횟수를 누적함.
 * Sort_row는 지금까지 정렬한 전체 레코드 

3. GROUP BY 처리

3.1 인덱스 스캔을 이용하는 GROUP BY
- 인덱스 이용해도 그룹 값 처리를 위해 임시 테이블이 필요할 때도 있다.
- 그룹핑 방식을 사용하는 쿼리의 실행 계획에서는 extra 컬럼에 별도로 group by 관련 코멘트가 없음.
3.2 루스 인덱스 스캔을 이용하는 GROUP BY
- 레코드를 건너뛰면서 필요한 부분만 가져오는 방식
- 단일 테이블에 대해 수행되는 그룹바이에만 이용할 수 있음.
- 인덱스의 유니크한 값의 수가 적을수록 성능이 향상된다. 루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일수록 더 빠른 결과를 냄
- 별도의 임시테이블 사용 안함.


3.3 임시 테이블을 사용하는 GROUP BY
- 인덱스 사용 불가할 경우 
- using temporary; using filesort 됨

4. DISTICT 처리
4.1 SELECT DISTINCT
- GROUP BY와 거의 유사함.정렬이 되냐마냐의 차이
-  select 절에 사용된 distinct 키워드는 조회되는 모든 컬럼에 영향을 미침
4.2. 집합 함수와 함께 사용된 distinct
- select count(distinct s.salary) 와 같이 사용 가능.
- 위와 같은 쿼리 형식은 내부적으로 임시 테이블 사용하나, extra 컬럼에는 using temporary가 표시되지 않음
- select count(distinct emp_no) 와 같이 인덱스된 칼럼에 대해 처리를 수행할 때는 임시 테이블 없이 최적화된 처리를 수행할 수 있다.
5. 임시테이블
- 임시테이블은 다른 세션이나 쿼리에서는 볼 수 없고, 사용도 불가. 쿼리가 완료되면 자동으로 삭제됨.
5.1 임시테이블이 필요한 쿼리
- order by와 group by에 명시된 컬럼이 다른 쿼리
- order by와 group by에 명시된 컬럼이 조인의 순서상 첫번째 테이블이 아닌 쿼리
- distinct와 order by가 동시에 쿼리에 존재하는 경우 또는 distinct가 인덱스로 처리되지 못하는 쿼리
- union이나 union distinct가 사용된 쿼리(select_type컬럼이 union result인 경우)
- union all이 사용된 쿼리(select_type컬럼이 union result인 경우)
- 쿼리의 실행계획에서 select_type이 derived인 쿼리
* 마지막 3개 패턴은 임시 테이블을 사용하지만 using temporary가 표시되지 않는다.
* 유니크 인덱스가 있는 내부 임시 테이블은 그렇지 않은 쿼리보다 상당히 느리다.
5.2 임시 테이블이 디스크에 생성되는 경우 (aria 스토리지 엔진을 사용)
- 내부 임시 테이블은 기본적으로 메모리 상에 만들어짐
- 다음과 같은 경우는 디스크 상에 생성됨
 * 임시 테이블에 저장해야 하는 내용중 blob나 text같은 대용량 컬럼이 있는 경우
 * 임시 테이블에 저장해야 하는 레코드의 전체 크기나 union이나 union all에서 select 되는 컬럼 중에서 길이가 512바이트 이상인 크기의 컬럼이 있는 경우
 * group by나 disticnt 컬럼에서 512바이트 이상인 크기의 컬럼이 있는 경우
 * 임시 테이블에 저장할 데이터의 전체 크기가 tmp_table_size 또는 max_heap_table_size시스템 설정 값보다 큰 경우
5.3 임시 테이블 관련 상태 변수
- using temporary 
- 쿼리 날리기 전/후를 비교해본다.
- 추가 정보를 보려면 show session status like 'created_tmp%'를 볼것
 * created_tmp_tables : 쿼리 처리를 위해 생성된 임시 테이블 개수 누적 값. (디스크/메모리 무관하게 누적됨)
 * created_tmp_disk_tables : 디스크에 내부 임시테이블이 만들어진 개수만 카운트 함.  
 
5.4 인덱스를 가지는 내부 임시 테이블
- 실행 계획 확인했을때 테이블이 derived이고 key0와 같은 식으로 생성되어 있다면 내부적으로 인덱스를 생성한 것
- set optimizer_switch='derived_with_keys=on'과 같이 설정 가능

5.5 내부 임시 테이블의 주의사항
- 가능하면 인덱스 사용
- 임시 테이블을 최대 만들지 않도록 하되, 그게 어렵다면 내부 임시 테이블이 메모리에만 생성될 수 있도록 할 것.
- tmp_table_size 또는 max_heap_table_size 무조건 크게 하면 안됨.
- 임시테이블은 테이블에 저장된 크기만 큼 메모리 테이블에서 공간을 차지하기 때문에 select 하는 컬럼은 최소화하고, 컬럼의 데이터 타입 선정도 가능한 작게 해줄것.
